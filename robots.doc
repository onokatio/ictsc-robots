**** この文書は印刷してはならない：地球にやさしいエコライフ ****

1 テーマ
  ゲーム“robots”を簡略化したプログラムを作成する．“robots”は，古くから UNIX オペレーティングシステムに付属してきた由緒正しいゲームである．

2 robots のルール
2.1 概要
  プレイヤは悪いロボットと戦っている．下の図で，‘@’がプレイヤ，‘+’がロボットを表す．

	+------------------------------------------------------------+
	|                                                            |
	|                                                            |
	|                                                            |
	|  +                                                         |
	|             @ *                                  +         |
	|                                                         +  |
	|           +                                                |
	|                                                            |
	|          +                                                 |
	|                                                            |
	|                                                            |
	|                                               +            |
	|                                                            |
	|   +                                                        |
	|                *                                           |
	|                                                            |
	|                                  +                         |
	|                                        +                   |
	|          +                                                 |
	|                                                            |
	+------------------------------------------------------------+

  プレイヤは，1 回の動作で 8 方向（上下左右と斜め）のいずれかに 1 ます移動することができる．または，まったく動かないこと，どこかにテレポートする（行き先はランダムに決まる）ことも選択可能である．
  プレイヤが動くと，次にロボットが移動する．ロボットも 8 方向のいずれかに 1 ます移動できる．ロボットは，常にプレイヤに最も接近する方向に移動する．
  ロボットどうしが衝突すると，壊れてスクラップになる．また，ロボットがスクラップに衝突した場合も，そのロボットは壊れる．スクラップは‘*’で表される．
  プレイヤがロボットに捕まるとゲームオーバである．フィールド上のすべてのロボットが壊れると，次のフィールドが現れる．

2.2 動作の制約
  2.1 で述べたようにプレイヤは，8 方向に 1 ますずつ移動できる．ただし，

	フィールドの外
	ロボットのいる場所
	スクラップのある場所

には移動することができない．
  プレイヤがテレポートをしたときの行き先は，でたらめに決められる．ただし，上にあげた移動不可能な場所にテレポートすることはない．
  ロボットは，フィールドの中のどの場所にも移動することができる．

2.3 ゲームの設定
2.3.1 ゲームレベルとロボットの数
  ゲームが始まったとき，プレイヤのレベルは 1 である．フィールド中のロボットを全滅させるごとに，レベルがひとつ上がる．
  フィールドに配置されるロボットの数は，

	min(レベル×5,40)

とする．ただし，min(x,y) は x と y のうち小さい方をとる関数である．つまり，フィールドに現れるロボットの数は，

	5, 10, 15, ... , 35, 40, 40, …

になる．

2.3.2 スコア
  ロボットを 1 台破壊するごとに，1 点が与えられる．また，ロボットを全滅させるごとに，レベル×10 点のボーナスが与えられる．
  たとえば，最初のフィールドをクリアすると，

	5（ロボットの数）＋ 1（レベル）× 10 ＝ 15（点）

が得られる．

2.4 使い方
  プログラムは，フィールドの状態を描いたあと，

    (level:1 score:0):?

を表示して入力を待つ（“level”，“score”はそれぞれ現在のレベル，得点である）．ユーザは，動く方向等を次のように 0〜9 の数字で入力する（キーボード右側の数字キーの配置が，移動方向に対応している）．

    0: テレポート
    1: 左下
    2: 下
    3: 右下
    4: 左
    5: 待機
    6: 右
    7: 左上
    8: 上
    9: 右上

3 課題
3.1 プログラムの理解
  プログラム“/home/jugyou/j4/2010-prog_enshuu/robots/robots”を実行して，課題がどんなプログラムであるのか調べる．

3.2 データ表現の検討
  あるロボットが座標(x,y) にいることを，プログラム中でどのように表現するかを考えよう．
  まず思い付くのは，

     int  field[60][20];

のように，フィールドを配列として作り，

     field[x][y] = TRUE   ... (x,y) にロボットがいる（※）
                 = FALSE  ... (x,y) にロボットがいない

として表す方法である．
※注 ロボットの画面上での表示文字が '+' だからといって，プログラム内部でロボットを '+' で表すのは，多分あまりよいアイデアではない．

  別のやり方として，

     struct r{
         int x;
         int y;
     };

     struct r robot[40];

という構造体の配列を作って，

     robot[i].x = a; robot[i].y = b;  → Ri が (a,b) にいる

のように表すことも可能である（配列のかわりにリストを用いてもよい）．
  どちらの方法でもrobots の存在を記述することが可能なので，その意味では両者の能力は同等である．しかし，プログラムの実行効率，書きやすさの点で差があるかもしれない．
  たとえば，次の処理をそれぞれの方法で行う場合，計算の手間はどうなるだろうか．また，そもそも実現可能だろうか．

(1) 全ロボットを *** 1 回ずつ *** 移動させる（かつスクラップは動かさない）
(2) ロボット同士，ロボットとスクラップまたはロボットとプレイヤの衝突を検出する
(3) （画面表示などのために）(x,y) にロボットがいるかどうかを調べる

  (1)〜(3)を検討すると，二つの方法はいずれも長所，短所を持っていることがわかるはずである．そこで次に，

  ・欠点を補えるような改良を加える
  ・二つを組み合わせて使う
  ・まったく別の表現方法を考案する

などを考えることが必要になる．

3.3 robots プログラムの作成
  “robots”プログラムを作成する．いきなりコーディングを始めるのではなく，データ構造や処理の流れ（関数）を設計してから，その設計にしたがってプログラムを作成すること．

3.4 発展課題
  余力があったら機能を付け加えよう．

・「これ以降は動かない」コマンド
　ロボットが全滅する or 自分がつかまるまで動かない．動かない間に壊れたロボットについては得点が少し高くなる．
・ハイスコアの保存
　得点記録をファイルに保存する．
・さまざまな拡張（ルールの変更）
　・速いロボット，遅いロボット，でたらめに動くロボット，丈夫なロボットの導入
　・3次元“robots”
　・フィールドに特殊アイテムが現れ，拾うと使えるようにする
　　影武者
　　シールド
　　倍速
　　時限爆弾
　　ボーナスポイント

　※でも，“robots”はシンプルだからこそおもしろいのかもしれない

3.5 文字入力関数 getChar()
  “hangman”のときと同じく，今回の課題でも1文字単位の文字入力関数 getChar() を利用する．ただし，今回は自分のソースプログラムに読み込むのではなく，別個にコンパイルしたオブジェクトファイルをリンクして使う方法をとる．
  手順は次のとおりである．
  まず，“getchar.c”をコンパイルし，オブジェクトファイルを作成する（“getchar.c”を変更しない限り，一度だけでよい）．

    % cc -c getchar.c

  オプション“-c”を指定すると，コンパイラはソースプログラム（getchar.c）をコンパイルしてオブジェクトコード（getchar.o）を生成したところで停止する（オプションをつけなければ，このあとリンクを行なって実行ファイルを生成しようとして失敗するだろう）．
  他のプログラムから getChar() を利用する場合，“getchar.o”をリンクする．たとえば，“robots.c”から getChar() を呼び出すなら，

    % cc -c robots.c
    % cc robots.o getchar.o -o robots

を実行すればよい．上の 2 行目で“cc”は，“robots.o”と“getchar.o”をリンクして（内部でリンカプログラム“ld”を呼び出す），実行ファイルを作成する．
  ただし，“robots.c”側では getchar() の引数や戻り値を知らないので，外部参照宣言によって教えてやる必要がある．具体的には，“robots.c”の先頭付近に，

    extern char getChar(void);

という行を追加する．
  上の例では“robots.c”のコンパイルとリンクを分けて行なっているが，“cc”はファイルの拡張子を調べて適切な処理をしてくれるので，

    %cc robots.c getchar.o -o robots

のように，ソースファイルやオブジェクトファイルを混ぜて与えてもよい．

4 レポート
  次の内容を含む最終レポートを提出しなさい．

(1) プログラムの仕様（外部仕様，内部仕様）
      ・プログラムの機能
      ・プログラムの使い方
      ・主要なデータ構造
      ・各関数の仕様（引数，戻り値・副作用，処理内容）
(2) プログラムの正しさの検証
      たとえば：
      ・衝突，ゲームオーバの処理が正しく行なわれていることの確認
      ・想定外の文字を入力されても破綻しないことの確認
(3) 各処理の計算量
      ※robots2.doc を参照
(4) 付録としてプログラムリスト
      ・適切なコメントを含むこと
      ・インデントをつけるなど，読みやすさに配慮すること
      ・2段組フォーマットが望ましい（紙資源を大切にしよう）

5.3 レポート提出先等
  学籍番号に応じて，各教員のレポートボックスに提出する．所定の表紙を用い，共同実験者以外の項目はもれなく記入すること．
  提出先は，次のとおりとする．

  学籍番号が奇数→丸山
            偶数→大枝

  提出期限 ?? 月 ?? 日
